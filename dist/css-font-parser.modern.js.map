{"version":3,"file":"css-font-parser.modern.js","sources":["../src/parser.js"],"sourcesContent":["/**\n * @enum {number}\n */\nconst states = {\n  VARIATION: 1,\n  LINE_HEIGHT: 2,\n  FONT_FAMILY: 3,\n  BEFORE_FONT_FAMILY: 4,\n  AFTER_OBLIQUE: 5,\n  ESCAPING: 6,\n  IDENTIFIER: 7,\n  HEXESCAPING: 8,\n};\n\n/**\n * Returns true if the identifier is valid.\n * @param {string} identifier\n * @return {boolean}\n */\nfunction isValidIdentifier(identifier) {\n  return !/^(-?\\d|--)/.test(identifier);\n}\n\n/**\n * Attempt to parse a string as an identifier. Return\n * a normalized identifier, or null when the string\n * contains an invalid identifier.\n *\n * @param {string} str\n * @return {string|null}\n */\nfunction parseIdentifier(str) {\n  const identifiers = [];\n  let buffer = \"\";\n  let hex = \"\";\n  let state = states.IDENTIFIER;\n\n  for (let c, i = 0; (c = str.charAt(i)); i++) {\n    if (/[a-zA-Z\\d\\xa0-\\uffff_-]/.test(c) && state === states.IDENTIFIER) {\n      buffer += c;\n    } else if (c === \"\\\\\" && state === states.IDENTIFIER) {\n      state = states.ESCAPING;\n    } else if (c === \" \" && state === states.IDENTIFIER) {\n      if (buffer !== \"\") {\n        if (isValidIdentifier(buffer)) {\n          identifiers.push(buffer);\n          buffer = \"\";\n        } else {\n          return null;\n        }\n      }\n    } else if (state === states.ESCAPING) {\n      if (/[0-9a-f]/i.test(c)) {\n        hex += c;\n        state = states.HEXESCAPING;\n      } else {\n        buffer += c;\n        state = states.IDENTIFIER;\n      }\n    } else if (state === states.HEXESCAPING) {\n      if (/[0-9a-f]/i.test(c) && hex.length < 6) {\n        hex += c;\n      } else {\n        buffer += String.fromCodePoint(parseInt(hex, 16));\n        buffer += c;\n        hex = \"\";\n        state = states.IDENTIFIER;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  if (buffer !== \"\") {\n    if (isValidIdentifier(buffer)) {\n      identifiers.push(buffer);\n    } else {\n      return null;\n    }\n  }\n\n  return identifiers.join(\" \");\n}\n\n/**\n * @param {string} input\n * @param {states} initialState\n * @return {Object|null}\n */\nfunction parse(input, initialState) {\n  let state = initialState;\n  let buffer = \"\";\n  const result = {\n    \"font-family\": [],\n  };\n\n  for (let c, i = 0; (c = input.charAt(i)); i += 1) {\n    if (state === states.BEFORE_FONT_FAMILY && (c === '\"' || c === \"'\")) {\n      let index = i + 1;\n\n      // consume the entire string\n      do {\n        index = input.indexOf(c, index) + 1;\n        if (!index) {\n          // If a string is not closed by a ' or \" return null.\n          return null;\n        }\n      } while (input.charAt(index - 2) === \"\\\\\");\n\n      result[\"font-family\"].push(\n        input.slice(i + 1, index - 1).replace(/\\\\('|\")/g, \"$1\")\n      );\n\n      i = index - 1;\n      state = states.FONT_FAMILY;\n      buffer = \"\";\n    } else if (state === states.FONT_FAMILY && c === \",\") {\n      state = states.BEFORE_FONT_FAMILY;\n      buffer = \"\";\n    } else if (state === states.BEFORE_FONT_FAMILY && c === \",\") {\n      const identifier = parseIdentifier(buffer);\n\n      if (identifier) {\n        result[\"font-family\"].push(identifier);\n      }\n      buffer = \"\";\n    } else if (state === states.AFTER_OBLIQUE && c === \" \") {\n      if (/^(?:\\+|-)?(?:[0-9]*\\.)?[0-9]+(?:deg|grad|rad|turn)$/.test(buffer)) {\n        result[\"font-style\"] += \" \" + buffer;\n        buffer = \"\";\n      } else {\n        // The 'oblique' token was not followed by an angle.\n        // Backtrack to allow the token to be parsed as VARIATION\n        i -= 1;\n      }\n      state = states.VARIATION;\n    } else if (state === states.VARIATION && (c === \" \" || c === \"/\")) {\n      if (\n        /^(?:(?:xx|x)-large|(?:xx|s)-small|small|large|medium)$/.test(buffer) ||\n        /^(?:larg|small)er$/.test(buffer) ||\n        /^(?:\\+|-)?(?:[0-9]*\\.)?[0-9]+(?:em|ex|ch|rem|vh|vw|vmin|vmax|px|mm|cm|in|pt|pc|%)$/.test(\n          buffer\n        )\n      ) {\n        state = c === \"/\" ? states.LINE_HEIGHT : states.BEFORE_FONT_FAMILY;\n        result[\"font-size\"] = buffer;\n      } else if (/^italic$/.test(buffer)) {\n        result[\"font-style\"] = buffer;\n      } else if (/^oblique$/.test(buffer)) {\n        result[\"font-style\"] = buffer;\n        state = states.AFTER_OBLIQUE;\n      } else if (/^small-caps$/.test(buffer)) {\n        result[\"font-variant\"] = buffer;\n      } else if (/^(?:bold(?:er)?|lighter|normal)$/.test(buffer)) {\n        result[\"font-weight\"] = buffer;\n      } else if (\n        /^[+-]?(?:[0-9]*\\.)?[0-9]+(?:e[+-]?(?:0|[1-9][0-9]*))?$/.test(buffer)\n      ) {\n        const num = parseFloat(buffer);\n        if (num >= 1 && num <= 1000) {\n          result[\"font-weight\"] = buffer;\n        }\n      } else if (\n        /^(?:(?:ultra|extra|semi)-)?(?:condensed|expanded)$/.test(buffer)\n      ) {\n        result[\"font-stretch\"] = buffer;\n      }\n      buffer = \"\";\n    } else if (state === states.LINE_HEIGHT && c === \" \") {\n      if (\n        /^(?:\\+|-)?([0-9]*\\.)?[0-9]+(?:em|ex|ch|rem|vh|vw|vmin|vmax|px|mm|cm|in|pt|pc|%)?$/.test(\n          buffer\n        )\n      ) {\n        result[\"line-height\"] = buffer;\n      }\n      state = states.BEFORE_FONT_FAMILY;\n      buffer = \"\";\n    } else {\n      buffer += c;\n    }\n  }\n\n  // This is for the case where a string was specified followed by\n  // an identifier, but without a separating comma.\n  if (state === states.FONT_FAMILY && !/^\\s*$/.test(buffer)) {\n    return null;\n  }\n\n  if (state === states.BEFORE_FONT_FAMILY) {\n    const identifier = parseIdentifier(buffer);\n\n    if (identifier) {\n      result[\"font-family\"].push(identifier);\n    }\n  }\n\n  return result;\n}\n\nfunction parseFontFamily(str) {\n  const result = parse(str, states.BEFORE_FONT_FAMILY);\n\n  if (result !== null) {\n    return result[\"font-family\"];\n  } else {\n    return null;\n  }\n}\n\nfunction parseFont(str) {\n  const result = parse(str, states.VARIATION);\n\n  if (result !== null && result[\"font-size\"] && result[\"font-family\"].length) {\n    return result;\n  } else {\n    return null;\n  }\n}\n\nexport { parseFont, parseFontFamily };\n"],"names":["isValidIdentifier","identifier","test","parseIdentifier","str","identifiers","buffer","hex","state","c","i","charAt","push","length","String","fromCodePoint","parseInt","join","parse","input","initialState","result","parseFloat","num","index","indexOf","slice","replace","parseFontFamily","parseFont"],"mappings":"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"}